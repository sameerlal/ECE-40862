import esp32;
import random;
import os;
import ubinascii;
import machine;
import hmac, hashlib;
import json;
import struct;
from ucryptolib import aes;
from random import randint;

class CryptAes:
  """Uses AES encryption to encrypt Payload/Data before sending using MQTT protocol
  The AES algo uses Cipher Block Chaining (CBC)
  AES encryption correctly requires three things to produce ciphertext:
  a message: Payload/Data which is to be encrypted,
  a key: Piece of information (a parameter) that determines the functional output of a
    cryptographic algorithm. For encryption algorithms, a key specifies transformation
    of plaintext into ciphertext, and vice versa for decryption algorithms.
  initialization vector (IV): Piece of data sent along with the key that modifies the end
    ciphertext result. As the name suggests, it initializes the state of the encryption
    algorithm before the data enters. This protects against attacks like pattern analysis.
    This needs to be DIFFERENT for every message.
    
  Uses sessionID (received from Spinner #2) and Encrypted Data to generate HMAC for 
  authentication of the sending device (Spinner #1)
  SessionID is generated by Spinner #2 by posting to the MQTT topic, SessionID every 1 sec.
  
  HMAC (hash-based message authentication code): Type of message authentication code (MAC)
  involving a cryptographic HASH function and a secret cryptographic key. It may be used to
  simultaneously verify both the data integrity and the authentication of a message.
  """  

  def __init__(self, sessionID):
    """
    This class initializes all keys and ids
    nodeid     : unique id to identify device or board
    iv         : pseudorandom initialization vector, this needs to be DIFFERENT for every message.
    staticiv   : static initialization vector to obfuscate the randomized
            initialization vector sent with each message, NOT used for any data
    ivkey      : unique key to encrypt the initialization vector
    datakey    : unique key to encypt the Payload/Data
    passphrase : key to generate the HMAC code for authentication
    
    sessionID  : unique value to identify the current communication session, generated only by Spinner #2
    
    ***********************NOTE******************************
    AES is a block cipher with a block size of 128 bits; that's why it encrypts 16 bytes at a time.        
    The block size of CBC mode of encryption is 16, make sure that any data going into AES
    Encryption is of size 16 bytes.
    """
    
    self.nodeid = "0000{}".format(ubinascii.hexlify(machine.unique_id()).decode());
    self.iv = str.encode(str(randint(10000000,99999999)) + str(randint(10000000,99999999)));
    self.staticiv = b"1111111111111111";
    self.ivkey = b"1111111111111111";
    self.datakey = b"1111111111111111";
    self.passphrase = b"sugondeseyurijoe";
    self.sessionID = sessionID;
    self.aesIV = aes(self.ivkey, 2, self.staticiv);
    self.aesData = aes(self.datakey, 2, self.iv);
    
    return; 

  def encrypt(self, sensor_data):
    self.encryptednodeid = self.aesData.encrypt(self.nodeid);
    self.encryptediv = self.aesIV.encrypt(self.iv);
    self.encryptedxAccel = self.aesData.encrypt(sensor_data[0]);
    self.encryptedyAccel = self.aesData.encrypt(sensor_data[1]);
    self.encryptedzAccel = self.aesData.encrypt(sensor_data[2]);
    self.encryptedtemp = self.aesData.encrypt(sensor_data[3]);
    self.xAccel = sensor_data[0];
    self.yAccel = sensor_data[1];
    self.zAccel = sensor_data[2];
    self.temp = sensor_data[3];
    
    return;
  
  def sign_hmac(self, sessionID):
    return(hmac.new(self.passphrase, sessionID, hashlib.sha224).hexdigest());
    
  def send_mqtt(self, hmac_signed):
    """Prepare the message for MQTT transfer using all of encrypted iv, encrypted nodeid, 
    encrypted data, HMAC. Create the message in JSON format."""
    anottherJSON = "{}, {}, {}, {}, {}, {}, {}".format(str(hmac_signed), str(self.nodeid), str(self.iv), str(self.xAccel), str(self.yAccel), str(self.zAccel), str(self.temp));
    """
    :param hmac_signed  : generated HMAC
    :return       : MQTT message to publish to Spinner #2 on Topic "Sensor_Data"
    """
    
    anotherJSON = {"HMAC": str(hmac_signed), "nodeid": str(self.nodeid), "iv": str(self.iv), "xAccel": str(self.xAccel), "yAccel": str(self.yAccel), "zAccel": str(self.zAccel), "temp": str(self.temp)};
    anotherJSON = json.dumps(anotherJSON);
    
    return(anottherJSON);
    
  def verify_hmac(self, payload):
    """Authenticates the received MQTT message. 
    Generate HMAC using passphrase, sessionID, RECEIVED encrypted iv, encrypted nodeid, encrypted data 
    and compare with received hmac inside payload to authenticate.
    :param payload  : received MQTT message from Spinner #1. This includes all encrypted data, nodeid, iv, and HMAC
    :return message : MQTT message to publish to Spinner #1 on Topic "Acknowledge", can be "Failed Authentication" 
              if verification is unsuccessful
    """
    HMAC = hmac.new(self.passphrase, self.sessionID, hashlib.sha224).hexdigest()
    if HMAC == payload["HMAC"]:
        return True

  def decrypt(self, payload):
    """Decrypts the each encrypted item of the payload.
    Initialize decryption cipher for each item and and use cipher to decrypt payload items.
    :param payload  : received MQTT message from Spinner #1. This includes all encrypted data, nodeid, iv, and HMAC
    :return     : MQTT message to publish to Spinner #1 on Topic "Acknowledge", can be "Successful Decryption"
    """
    HMAC, NodeID, IV, X, Y, Z, Temp = payload.split(",")
    x = self.aesData.decrypt("{:0>32}".format(X))
    y = self.aesData.decrypt("{:0>32}".format(Y))
    z = self.aesData.decrypt("{:0>32}".format(Z))
    iv = self.aesData.decrypt("{:0>32}".format(IV))
    temp = self.aesData.decrypt("{:0>32}".format(Temp))
    nodeID = self.aesData.decrypt("{:0>32}".format(NodeID))
    return {"HMAC": HMAC, "NodeID": NodeID, "IV": IV, "X": X, "Y": Y, "Z": Z, "Temp": Temp}